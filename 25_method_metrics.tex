\subsection{Metrics Engine}
The first pillar of the open framework is the metric engine ecosystem Graphite, which captures performance values over time. 
Started in 2006 it provides a modular system to consume, process, store and access metric information in the form 'key value time-stamp'.

The metrics are persisted in round-robin databases called whisper by a set of daemons called 'carbon'.

\begin{lstlisting}[language=bash,
    caption={Sending and receiving metrics using carbon in combination with a whisper file back-end.},
    label={lst:carbon_wsp}]
$ for x in {1..5};do
> echo "test.metric ${x} $(date +%s)" |\
    nc -w 1 127.0.0.1 2003
> sleep 5
> done
$ export CDIR=/var/lib/carbon/whisper
$ whisper-fetch $CDIR/test/metric.wsp |\
    grep -v None
1438513460	1.000000
1438513465	2.000000
1438513470	3.000000
1438513475	4.000000
1438513480	5.000000
$
\end{lstlisting}

The graphite framework provides a rich ecosystem of visualizations, plugins, metric sources and alternative daemon implementation to fit almost
all use-cases around metrics gathering, processing, storing and serving metrics. Due to its open-source development and stable API, missing pieces
can be added if needed.

This enables each part of the infrastructure layer to submit metrics without much effort. Even application developers can just start sending metrics down the pipeline and
let them pop up at the access layer.

\subsubsection{Metric Key Scheme}

If the group of metric generators grows to a certain complexity, the metrics keys becoming a problem, since naming schemes vary depending on the context of
the producer. An engineer overseeing the network in a data-center might organize his metrics hierarchical (\lstinline{datacenter01.rack01.compute01.eth0.send_bytes}), while from the
resource scheduler perspective a grouping per job (\lstinline{jobid01.compute01.send_bytes}) is a scheme which might fit the use-case best.

To overcome this issue a scheme should be chosen which abstract from a metric key as single string.
Concepts like Metrics 2.0\footnote{\Mundus~\url{http://metrics20.org/}} (shown in \autoref{lst:metrics20}) annotate metrics with metadata.

\begin{lstlisting}[language=bash,
    caption={Metrics2.0 formatted metric},
    label={lst:metrics20}]
{
    server: dfs1
    what: diskspace
    mountpoint: srv/node/dfs10
    unit: B
    type: used
    metric_type: gauge
    value: 1024
}
meta: {
    agent: diamond,
    processed_by: statsd2
}
\end{lstlisting}
